---
title: 有趣的C语言小测试
date: 2017-09-01 14:07:31
tags: [C基础]
categories: C语言
---
## 引言
C语言是其他语言拓展的基石，如对库的支撑，C语言暂时不敢变，变了岂不好多人要失业，高级语言可以玩出很多变化，但是偏底层靠的是基础，俗话说万变不离其宗，基础扎实才是拓展的前提。

## 题目
下面各个题目输出是什么呢？32位操作系统
### 测试一
unsigned int a = 6;
int b = -20;
(a+b > 0)? puts("why") : puts("I don‘t no");
### 测试二
int ar[] ={6,7,8,9,10};
int *ptr=ar;
*(ptr++)+=123;
printf("%d,%d \n",*ptr,*(++ptr));	
printf("%d%d%d\n",ar[0],ar[1],ar[2]);
### 测试三
int a[3] = {1,11,22};
int *p = a; 
printf("*p++ = %d\n",*p++);
printf("*++p = %d\n",*++p);
### 测试四
int a[5] = { 1 , 2 , 3 , 4 , 5 };
int *ptr = (int *)( (char*) a + 1 );
printf("%#x\n",*ptr);	
### 测试五
求一个字符串长度，不要用库函数，不要用中间变量

## 结果
### 测试一
无符号整型问题的答案是输出是“why”。
原因是当表达式中存在有符号
类型和无符号类型时所有的操作数都自动转换为无符号类型。因此-20变成了一个非常大
的正整数，所以该表达式计算出的结果大于0。
### 测试二
输出依次是 8  8  129  7  8
拆开后看是这样的
*ptr += 123；
ptr++；
++ptr；
printf("%d,%d \n",*ptr,*ptr);
printf("%d%d%d\n",ar[0],ar[1],ar[2]);
### 测试三
输出为1 22 
计算顺序
printf("*p++ = %d\n",*p);
p++;
++p;
printf("*++p = %d\n",*p);
### 测试四
结果 0x2000000
数据在内存的储存形式
### 测试五
可以用递归
int getlen(char*s)
{
    if(*s == '\0')
        return 0;
    s++;
    return getlen(s) + 1;
}

## 总结
不要小看一些细小的额东西，有些错误很难发现有可能就是因为这些越细小的基础造成的








